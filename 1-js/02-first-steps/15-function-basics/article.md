# ฟังก์ชั่น (Functions)

บ่อยครั้งที่เราเขียนโปรแกรม จะต้องมีชุดงานหนึ่งๆที่อยากจะให้มันทำงานซ้ำๆ ในหลายๆที่ของไฟล์สคริปต์

ตัวอย่างเช่น เราต้องการแสดงข้อความที่ดูดีเมื่อผู้ใช้ล็อคอินเข้าสู่ระบบ ออกจากระบบ หรือเข้าไปตามหน้าต่างๆ

ฟังก์ชั่นเป็น "building blocks" หลักของโปรแกรม เราสามารถเรียกใช้ได้หลายๆครั้ง

เราได้เห็นฟังก์ชั่นพวกนี้กันมาบ้างแล้วอย่างเช่น `alert(message)`, `prompt(message, default)` และ `confirm(question)` ฟังก์ชั่นเหล่านี้เป็นฟังก์ชันที่เบราเซอร์มีมาให้ แต่เราสามารถสร้างฟังก์ชันได้ด้วยตัวเองได้ด้วย

## การประกาศฟังก์ชั่น

เราสร้างฟังก์ชันโดยใช้ *การประกาศฟังก์ชั่น*.

โดยที่มันมีหน้าตาแบบนี้:

```js
function showMessage() {
  alert( 'Hello everyone!' );
}
```

เราเขียน `function` ก่อน ตามด้วย *ตั้งชื่อให้ฟังก์ชัน* ตามด้วย *พารามิเตอร์* ที่อยู่ระหว่างวงเล็บ (เราใช้ลูกน้ำเพื่อให้ฟังก์ชันรับพารามิเตอร์ได้หลายตัว) และสุดท้ายปีกกาหรือ "the function body" เป็นคำสั่งที่เราอยากให้โปรแกรมทำงานเมื่อเราเรียกใช้ฟังก์ชันนี้

```js
function name(parameter1, parameter2, ... parameterN) {
  ...body...
}
```

เราสามารถใช้ฟังก์ชั่นที่เราสร้างขึ้นมาได้โดยเรียกผ่านชื่อของมันตามด้วยวงเล็บเปิด-ปิด `showMessage()`

ตัวอย่าง:

```js run
function showMessage() {
  alert( 'Hello everyone!' );
}

*!*
showMessage();
showMessage();
*/!*
```

จากโค้ดด้านบนจะเห็นว่าเราเรียกฟังก์ชั่น `showMessage()` ทำงาน 2 ที ที่นี่เราเลยเห็น `alert` ออกมาสองครั้ง

เราจะเห็นได้จากตัวอย่างด้านบนว่า วัตถุประสงค์หลักของฟังก์ชั่นคือลดความซ้ำซ้อนของโค้ดลง

หากเราต้องการจะแก้ไขข้อความที่แสดง เราก็แค่ไปแก้ไขในฟังก์ชั่นตัวนั้นแทน

## ตัวแปรภายใน (Local variables)

ตัวแปรภายใน (Local variables) คือตัวแปรที่ประกาศภายในฟังก์ชั่น จะมองเห็นได้เฉพาะในฟังก์ชั่นเท่านั้น

For example:

```js run
function showMessage() {
*!*
  let message = "Hello, I'm JavaScript!"; // ตัวแปรภายใน
*/!*

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! ตัวแปรนี้เป็นตัวแปรภายในมองเห็นได้เฉพาะภายในฟังก์ชั่น showMessage เท่านั้น
```

## ตัวแปรภายนอก (Outer variables)

ฟังก์ชั่นสามารถเข้าถึงตัวแปรภายนอกได้ ตัวอย่างเช่น

```js run no-beautify
let *!*userName*/!* = 'John';

function showMessage() {
  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Hello, John
```

ฟังก์ชั่นเข้าถึงตัวแปรภายนอกได้อย่างเต็มรูปแบบ นั่นหมายความว่ามันสามารถแก้ไขของที่อยู่ในตัวแปรได้ด้วย

ตัวอย่างเช่น

```js run
let *!*userName*/!* = 'John';

function showMessage() {
  *!*userName*/!* = "Bob"; // (1) เป็นค่าของตัวแปรภายนอก

  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* ก่อนฟังก์ชั่นจะถูกเรียก ยังเป็น John อยู่

showMessage();

alert( userName ); // *!*Bob*/!*, มาดูตัวแปรหลังฟังก์ชั่นถูกเรียก จะเห็นว่าเป็น Bob ไปแล้ว
```

ตัวแปรภายนอกจะถูกใช้ก็ต่อเมื่อไม่มีตัวแปรภายในให้ใช้

หากมีการประกาศตัวแปรภายนอกกับภายในชื่อเดียวกัน ฟังก์ชั่นจะใช้ตัวแปรที่อยู่ภายในแทน ดูจากตัวอย่างด้านล่าง

```js run
let userName = 'John';

function showMessage() {
*!*
  let userName = "Bob"; // ประกาศตัวแปรภายใน
*/!*

  let message = 'Hello, ' + userName; // *!*Bob*/!*
  alert(message);
}

// the function will create and use its own userName
showMessage();

alert( userName ); // *!*John*/!*, unchanged, the function did not access the outer variable
```

```smart header="ตัวแปรภายนอก (Global variables)"
ตัวแปรภายนอกคือตัวแปรที่ประกาศข้างนอกฟังก์ชั่น อย่างเช่นโค้ดจากด้านบน ตัวแปรชื่อ `userName` จะเรียกว่าตัวแปรภายนอก (Global variables)

ตัวแปรภายนอกทุกฟังก์ชั่นสามารถมองเห็นได้ (ยกเว้นแต่จะเป็นตัวแปรภายในที่ชื่อเดียวกันกับตัวแปรภายนอก)

แนวทางปฎิบัติที่ดี เราจะพยายามลดการใช้ตัวแปรภายนอกให้น้อยที่สุด ยิ่งโค้ดใหม่ๆยิ่งมีตัวแปรภายนอกไม่กี่ตัวหรือไม่ก็ไม่มีเลย ตัวแปรส่วนใหญ่จะอยู่ภายในฟังก์ชั่น แต่ตัวแปรภายนอกก็มีประโยชน์ โดยเราใช้เก็บข้อมูลระดับโปรเจค (project-level data)
```

## พารามิเตอร์

เราสามารถส่งข้อมูลใดๆเข้าไปประมวลผลในฟังก์ชั่นก็ได้โดยใช้พารามิเตอร์

ในจากตัวอย่างด้านล่าง ฟังก์ชั่นนี้มีสองพารามิเตอร์คือ `from` และ `text`

```js run
function showMessage(*!*from, text*/!*) { // สองพารามิเตอร์: from และ text
  alert(from + ': ' + text);
}

*!*showMessage('Ann', 'Hello!');*/!* // Ann: Hello! (*)
*!*showMessage('Ann', "What's up?");*/!* // Ann: What's up? (**)
```

เมื่อฟังก์ชั่นถูกเรียกในบรรทัด `(*)` และ `(**)` ค่าที่ถูกกำหนดถูกคัดลอกไปยังตัวแปรภายในคือ `from` และ `text` เพื่อให้ฟังก์ชั่นเรียกใช้พารามิเตอร์เหล่านี้ได้

นี่เป็นอีกหนึ่งตัวอย่าง: เรามีตัวแปร `from` ใส่ผ่านไปยังฟังก์ชั่น เราจะเห็นว่าข้างในฟังก์ชันเราเปลี่ยนค่าตัวแปร `from` ใหม่ แต่การเปลี่ยนแปลงนี้ไม่ได้กระทบกับตัวแปร `from` ที่อยู่ภายนอก เพราะเราเปลี่ยนผ่านพารามิเตอร์ซึ่งเป็นตัวคัดลอกของ `from` ภายนอกอีกที โปรดจำไว้ว่าฟังก์ชันจะได้รับค่าจากตัวแปรเวอร์ชั่นคัดลอกไปเสมอ

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // เปลี่ยนให้ "from" ดูโดดเด่นขึ้นมาหน่อย
*/!*

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// ต่าจาก "from" เหมือนกัน, แต่ฟังก์ชันจะจัดการกับค่าที่ก็อปปี้เสมอ
alert( from ); // Ann
```

เราเรียกค่าที่เราใส่เข้าไปในฟังก์ชั่นอีกชื่อหนึ่งว่า *อาร์กิวเมนต์ (argument)*

เพื่อให้กระจ่างมากขึ้น:

- พารามิเตอร์คือตัวแปรที่อยู่ในวงเล็บตอนประกาศฟังก์ชั่น (ตอนประกาศฟังก์ชันเราเรียกพารามิเตอร์)
- อาร์กิวเมนต์คือค่าที่ส่งผ่านไปยังฟังก์ชั่น เมื่อฟังก์ชั่นนั้นถูกเรียกใช้ (ตอนใช้ค่าที่ใส่ไปเรียกอาร์กิวเมนต์)

เราประกาศฟังก์ชั่นใส่พารามิเตอร์ แล้วตอนเรียกฟังก์ชั่นเราส่งผ่านค่าอาร์กิวเมนต์

จากตัวอย่างด้านบน ฟังก์ชั่น `showMessage` ประกาศด้วยสองพารามิเตอร์ เราเรียกฟังก์ชันนี้ส่งอาร์กิวเมนต์ไปสองตัวคือ `from` และ `"Hello"`

## ค่าเริ่มต้น (Default values)

เมื่อฟังก์ชั่นถูกเรียก แต่เราไม่ได้ใส่อาร์กิวเมนต์มา ค่าของตัวที่ไม่ได้ใส่จะเป็น `undefined`

กลับมากันที่ฟังก์ชั่น `showMessage(from, text)` มันสามารถถูกเรียกใช้ได้ โดยใส่อาร์กิวเมนต์แค่ตัวเดียว

```js
showMessage("Ann");
```

มันจะไม่ error ผลลัพธ์จะเป็น `"*Ann*: undefined"` จากการที่ค่า `text` ไม่ได้ถูกใส่มา จึงทำให้เป็น `undefined`

เราสามารถระบุค่าที่เรียกว่า "default" สำหรับพารามิเตอร์ได้ตอนประกาศฟังก์ชั่นโดยใช้  `=`:

```js run
function showMessage(from, *!*text = "no text given"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

ที่นี้หากพารามิเตอร์ `text` ไม่ถูกใส่ค่ามา ค่าของมันจะเป็น `"no text given"` แทน

`"no text given"` คือสตริง, แต่มันสามารถเป็นนิพจน์ (expression) ที่ซับซ้อนกว่านี้ก็ได้ เหมือนตอนเราประกาศตัวแปร โดยนิพจน์จะถูกประมวลผลเมืิ่อเราไม่ใส่ค่าเข้ามา ตามตัวอย่างด้านล่างดังนี้

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() จะทำงานก็ต่อเมื่อ พารามิเตอร์ `text` ไม่ถูกใส่ค่ามา
  // สิ่งที่ฟังก์ชัน anotherFunction() ส่งกลับมาจะเป็นค่าของ `text`
}
```

```smart header="การประมวลผลของค่าเริ่มต้นสำหรับพารามิเตอร์"
ในจาวาสคริปต์ ค่าเริ่มต้นสำหรับพารามิเตอร์ จะถูกประมวลผลทุกๆครั้งที่ ฟังก์ชั่นถูกเรียกโดยไม่มีค่าใส่เข้ามาในพารามิเตอร์นั้นๆ

จากตัวอย่างด้านบน ฟังก์ชั่น `anotherFunction()` จะไม่ถูกเรียกเลย หากพารามิเตอร์ `text` ถูกใส่ค่าเข้ามา

อีกทางหนึ่งคือ ฟังก์ชั่น `anotherFunction()` จะถูกเรียกทุกคร้ัง หากพารามิเตอร์ `text` ไม่ถูกใส่ค่าอะไรมาเลย
```

### กำหนดค่าเริ่มต้นทีหลัง

บางครั้งเราก็อยากกำหนดค่าเริ่มต้นสำหรับพารามิเตอร์หลังการประกาศฟังก์ชั่น

เราทำได้โดยเราสามารถตรวจสอบว่าพารามิเตอร์ที่ถูกส่งผ่านฟังก์ชั่น โดยเทียบกับ `undefined`

```js run
function showMessage(text) {
  // ...

*!*
  if (text === undefined) { // เช็คว่าพารามิเตอร์ถูกส่งเข้ามา
    text = 'empty message';
  }
*/!*

  alert(text);
}

showMessage(); // empty message
```

...หรือเราจะใช้ตัวดำเนินการ `||` ก็ได้

```js
function showMessage(text) {
  // หาก `text` เป็น falsy value สตริง empty จะถูกกำหนดให้เป็นค่าของ `text`
  text = text || 'empty';
  ...
}
```

จาวาสคริปต์ปัจจุบันนี้รับรอง [ตัวดำเนินการรวมเป็นโมฆะ (nullish coalescing operator)](info:nullish-coalescing-operator) `??` แล้ว เราใช้ตัวดำเนินการตัวนี้ดีกว่า ใช้ `||` เนื่องจากมันดัก falsy values ออกไปทั้งหมด แต่โดยมากเราก็จะ falsy values หลายตัวเป็นค่าเริ่มต้นเช่น สตริงเปล่า หรือ เลข `0` เป็นต้น

```js run
function showCount(count) {
  // หาก count เป็น undefined หรือ null ให้แสดง "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

## ส่งผลลัพธ์หรือค่ากลับ

ฟังก์ชั่นสามารถส่งค่ากลับสู่ ตัวแปร พารามิเตอร์ อาร์กิวเมนต์ หรืออะไรก็ตามที่เรียกใช้มันได้

ตัวอย่างที่ง่ายที่สุดคือ ฟังก์ชั่นที่ส่งผลลัพธ์จากสองจำนวนบวกกัน

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

คำสั่ง `return` สามารถใช้ตรงไหนก็ได้ภายในฟังก์ชั่น เมื่อโค้ดภายในฟังก์ชั่นทำงานทีละบรรทัดเรื่อยๆจนมาถึงบรรทัด `return` ฟังก์ชั่นจะหยุดทำงาน และค่าที่เรา `return` ถูกส่งกลับไปหาโค้ดที่เรียกมันเช่น ตัวแปร `result` ตามตัวอย่างด้านบน

เราสามารถใช้คำสั่ง `return` กับฟังก์ชั่นได้หลายครั้ง ตามตัวอย่างด้านล่าง

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('Do you have permission from your parents?');
*/!*
  }
}

let age = prompt('How old are you?', 18);

if ( checkAge(age) ) {
  alert( 'Access granted' );
} else {
  alert( 'Access denied' );
}
```

เราสามารถใช้คำสั่ง `return` โดยที่ไม่มีค่าได้ ทุกครั้งที่เจอคำสั่ง `return` ฟังก์ชั่นจะหยุดทำงานทันที

For example:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "Showing you the movie" ); // (*)
  // ...
}
```

ตามตัวอย่างโค้ดด้านบน หาก `checkAge(age)` ส่งค่า `false` กลับ `showMovie` จะไม่ทำงานที่ `alert` ต่อ

````smart header="ฟังก์ชั่นที่ `return` เปล่าๆ มันจะ returns `undefined` แทน"
หากฟังก์ชั่นไม่ส่งคทนค่ากลับ มันจะส่ง `undefined` กลับมาแทน

```js run
function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
```

หากเราไม่ใส่คำสั่ง `return` มันจะเหมือนกับเราเขียน `return undefined`:

```js run
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```

````

````warn header="อย่าเว้นบรรทัดใหม่ระหว่างค่าที่จะส่งกลับไปกับคำสั่ง return"
สำหรับนิพจน์​ (expression) ยาวๆ เราอาจจะเผลอไปเว้นบรรทัด แบบนี้:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
จะทำให้บรรทัดนี้ไม่ทำงาน เพราะตาวาสคริปต์จะมองว่าเป็นแบบโค้ดข้างล่าง

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

จึงเหมือนกับเราเขียน return ออกไปเปล่าๆ

หากเราต้องการส่งค่าที่เป็นนิพจน์ยาวๆออกไป เราแค่ให้มันอยู่บรรทัดเดียวกับคำสั่ง `return`  หรือใส่วงเล็บเปิด-ปิดตามตัวอย่างด้านล่าง

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```
ทีนี้โค้ดก็จะทำงานตามที่เราคาดหวังแล้ว
````

## การตั้งชื่อฟังก์ชั่น [#function-naming]

ฟังก์ชั่นคือการทำงาน ฉะนั้นชื่อของฟังก์ชั่นมักจะขึ้นด้วยคำกริยา มันควรเป็นชื่อที่สั้น กระชับ และสื่อความหมายได้ดีว่ามันจะทำอะไร คนอื่นที่อ่านโค้ดจะได้เข้าใจที่สิ่งฟังก์ชั่นนั้นๆทำด้วย

การตั้งชื่อฟังก์ชั่นด้วยคำกริยาบางครั้งก็ดูคลุมเครือ ไม่แน่ใจว่าจะสื่ออะไรกันแน่ ดังนั้นคนในทีมต้องมีข้อตกลงกันให้ดีว่า จะเลือกคำกริยาตัวไหนมาเพื่ออธิบายภาพทำงานของฟังก์ชั่นแต่ละตัวให้ชัดเจน

ตัวอย่างเช่น ฟังก์ชั่นที่มีชื่อเริ่มต้นด้วยคำว่า`"show"` ก็หมายถึงมันจะต้องแสดงอะไรบางอย่างออกมา

ชื่อของฟังก์ชั่นมักจะเริ่มต้นด้วย...

- `"get…"` -- ส่งค่าสักค่ากลับไป
- `"calc…"` -- ทำการคำนวณบางอย่าง
- `"create…"` -- สร้างบางอย่าง
- `"check…"` -- เช็คเงื่อนไขบางอย่างและส่งค่าบูลีนกลับไป

Examples of such names:

```js no-beautify
showMessage(..)     // แสดงข้อความ
getAge(..)          // ส่งค่าอายุกลับไป
calcSum(..)         // คำนวณผลรวมและส่งผลลัพธ์กลับ
createForm(..)      // สร้างฟอร์ม
checkPermission(..) // ตรวจสอบ permission ส่ง true/false กลับ
```

เมื่อเราใช้กริยานำหน้า มันจะช่วยให้เราเข้าใจได้ทันทีเลยว่าฟังก์ชั่นนี้ทำงานอย่างไร

```smart header="หนึ่งฟังก์ชั่น -- หนึ่งงาน"
หนึ่งฟังก์ชั่นควรทำงานเพียงแค่หนึ่งงานเช่นเดียวกับชื่อของมัน ไม่มากไปกว่านั้น

งานสองงานที่ไม่ได้เกี่ยวข้องกันควรแยกออกเป็นสองฟังก์ชั่น และในกรณีนี้ เราก็ควรสร้างฟังก์ชั่นที่ 3 เพื่อเรียกใช้ฟังก์ชั่นทั้งสอง

ตัวอย่างคร่าวๆหากไม่ได้ปฎิบัติตามกฎด้านบน:

- `getAge` -- จะแสดง `alert` ด้วย แทนที่มันจะทำหน้าที่ get แค่อย่างเดียว
- `createForm` -- จะไปแก้ไขเว็บเพจ เพิ่มแบบฟอร์ม แทนที่ที่มันจะควรและส่งค่าอย่างเดียว
- `checkPermission` -- จะแสดงข้อความ `access granted/denied` แทนที่จะทำการตรวจสอบสิทธิ์เข้าถึงและคืนผลลัพธ์กลับไป

ตัวอย่างเหล่านี้แค่สมมติเท่านั้น เราและทีมมีอิสระที่จะตกลงที่จะใช้คำกริยาเหล่านี้ในลักษณะอื่นๆ แต่ก็ไม่ควรฉีกออกไป โดยสรุปก็คือ เราควรมีความเข้าใจว่าฟังก์ชั่นแต่ละคนทำงานยังไงทันทีที่เห็นชื่อฟังก์ชั่น และทางทีมควรมีฉันทามติเรื่องชื่อฟังก์ชั่น
```

```smart header="ชื่อฟังก์ชั่นสั้นเกินไป"
โดยมากจะเกิดจากฟังก์ชั่นที่เรามักจะเรียกใช้บ่อยๆ เราไม่อยากที่จะพิมพ์เยอะ จึงทำการย่อชื่อจนเหลือนิดเดียว

ตัวอย่างเช่น, เราจะใช้ฟังก์ชั่นของ [jQuery](http://jquery.com) ได้จากเครื่องหมาย `$` ตามด้วยชื่อฟังก์ชั่นที่เราจะใช้ เข่นเดียวกันกับ [Lodash](http://lodash.com/) โดยเราจะเรียกฟังก์ชั่นด้วยเครื่องหมาย `_`

บางทีเรื่องเหล่านี้ก็เป็นข้อยกเว้น โดยปกติชื่อฟังก์ชั่นที่ดีควรกระชับและสื่อความหมาย
```

## ฟังก์ชั่น == คอมเม้นต์

ฟังก์ชั่นควรสั้นๆและทำงานเพียงอย่างเดียว หากฟังก์ชั่นใหญ่ เราควรแบ่งออกมาเป็นฟังก์ชั่นย่อยๆจะดีกว่า การทำเรื่องนี้ให้เป็นนิสัยเป็นเรื่องยาก แต่ถ้าฝึกจนเป็นนิสัยจะมีสิ่งดีๆเกิดขึ้นแน่นอน

การแยกฟังก์ชั่นใหญ่ๆ ออกมาเป็นฟังก์ชั่นเล็กๆยังช่วยให้เขียนเทสและดีบักง่ายอีกด้วย

ตัวอย่าง ลองเปรียบเทียบสองฟังก์ชั่น `showPrimes(n)` ด้านล่าง การทำงานคือแสดง [จำนวนเฉพาะ (prime numbers)](https://en.wikipedia.org/wiki/Prime_number) ออกมาเรื่อยๆจนถึงจำนวนที่ `n`

ฟังก์ชั่นตัวแรกใช้ label:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // a prime
  }
}
```

ฟังก์ชั่นที่สองใช้ อีกหนึ่งฟังก์ชั่น `isPrime(n)` เพื่อตรวจสอบว่าจำนวนนั้นเป็นจำนวนเฉพาะหรือไม่

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

จะเห็นว่าฟังก์ชั่นตัวที่สองเข้าใจง่ายกว่า จริงไหม? เราแทนที่โค้ดจำนวนหนึ่ง โดยการใช้ฟังก์ชั่นใหม่แทน เราจะเรียก code pattern แบบนี้ว่า *self-describing*

ดังนั้น เราจะสร้างฟังก์ชั่นขึ้นมาอีกตัวเพื่อให้โค้ดของเราดูเรียบร้อยขึ้นได้ โดยไม่จำเป็นต้องเป็นชุดโค้ดที่ใช้ซ้ำๆอย่างเดียว

## สรุป

การประกาศฟังก์ชั่นมีหน้าตาดังนี้:

```js
function name(parameters, delimited, by, comma) {
  /* code */
}
```

- ส่งที่ส่งผ่านพารามิเตอร์จะถูกคัดลอกไปยังตัวแปรภายในฟังก์ชั่น
- ฟังก์ชั่นสามารถเข้าถึงตัวแปรภายนอกได้ แต่จะทำงานจากภายในออกภายนอก โค้ดภายนอกฟังก์ชั่นจะไม่เห็นตัวแปรภายในฟังก์ชั่น
- ฟังก์ชั่นสามารถคืนค่าได้ แต่ไม่มี จะคืน `undefined` ออกมาแทน

เพื่อให้โค้ดเป็นระเบียบและเข้าใจง่าย ขอแนะนำให้ใช้ตัวแปรและพารามิเตอร์ภายในฟังก์ชั่น แทนตัวแปรภายนอก

ฟังก์ชั่นที่รับพารามิเตอร์เข้าไป จะคืนค่าออกมา เข้าใจง่ายกว่า ฟังก์ชั่นที่ไม่มีพารามิเตอร์ แต่อาศัยปรับเปลี่ยนตัวแปรภายนอกเอา

การตั้งชื่อฟังก์ชั่น:

- ชื่อควรอธิบายอย่างชัดเจนว่าทำอะไร
- ฟังก์ชั่นคือการกระทำ ดังนั้นชื่อฟังก์ชั่นจะใช้ภาษาพูด
- มีคำนำหน้าฟังก์ชั่นที่รู้จักกันดีเช่น `create…`, `show…`, `get…`, `check…` และอื่นๆ เพื่อบอกว่าฟังก์ชั่นนี้ทำอะไร

ฟังก์ชั่นเป็นส่วนสำคัญในการสร้างสคริปต์ ตอนนี้เราก็ได้เรียนพื้นฐานทั้งหมดเกี่ยวกับฟังก์ชั่นแล้ว เราสามารถเริ่มต้นเขียนฟังก์ชั่นตัวแรกของเราได้เลย เราจะวนกลับมาหาฟังก์ชั่นอีกหลายๆครั้ง ในหัวข้อที่ลึกยิ่งขึ้น และฟีเจอร์อื่นๆท่ีมีในฟังก์ชั่น
